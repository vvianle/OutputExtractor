#TRUSTED 4c0465270a9b485ad852cfb33de6b218d445fc4ebde3638885cb54dc8b153f6d4acdd423b07e4a1e6bc91653f2f4f83d7c0846d49feab411b4b3ccf1b3f154a1406720a485b50a774f629f03eca47b55bbd5c79c7d1ba92c8075eb6170175c12d7e5f8fae9ce9ea21b10673c13b7733d0d827f105560cbdeb244ca44d60c61763caec7261d56da758c8f6fea7db34305025b5a1537896c5871357a6ebaa136b9a7cd7afee556d0500c9c721966fcb77920d1d830443bd5382ff1525e58ad59fbead1943ccb2fcc08e0d8101c742dfda3b6b8b9058506587efcf4b833d9534131f23970bfc60ae6539df8141e5c2f7de49ad385be128425328a73055283a653593553592c973a73fdb01b00be6068258f2fb5534dec40e405c4cbca324dd61dbaefc4424216c143a3a3ae3c8bcc32626121b82d744cae62fecd4f3a6ef9c9e0e4ced2550f53e75b2fc30e0b9831d82cb667a223065ca396a9aaca44076e3ccd14714d44e430ccb8d1c3aa6d64186280f8143e506037d1fe993edcf62dfa2761b4363f1d69b503210c83ef0f57bc93746b7bd9a624859e30a7dad23cae18ac7f23a9c47702d4fd42ca8c8be23641bafef2777dcb9a0b767c1de744f7813e111ad3367ca7e22785b4fd672d6c72828d75eeef8a9d5f329fac5f7fe01bb7b52e6268968db8910f952391ec8c0615243c06f32b176cb56696bff2aac986a1e8883543
###
# (C) Tenable Network Security, Inc.
#
# This script is released under one of the Tenable Script Licenses and may not
# be used from within scripts released under another license without the
# authorization from Tenable Network Security Inc.
#
# @NOGPL@
#
# This include file provides functions used for Junos patch auditing
#
# junos.inc
#
# Revision: 1.12
###

include("global_settings.inc");

# Some constants used with the 'flags' parameter of check_model()
E_SERIES   = 1 << 0;
EX_SERIES  = 1 << 1;
G_SERIES   = 1 << 2;
IC_SERIES  = 1 << 3;
J_SERIES   = 1 << 4;
M_SERIES   = 1 << 5;
MX_SERIES  = 1 << 6;
SRX_SERIES = 1 << 7;
T_SERIES   = 1 << 8;
LN_SERIES  = 1 << 9;
JCS_SERIES = 1 << 10;
PTX_SERIES = 1 << 11;
QFX_SERIES = 1 << 12;
# It appears the only series that aren't routers are :
# EX / QFX (switches)
# IC (access control)
# JCS (control system)
ALL_ROUTERS = E_SERIES | G_SERIES | J_SERIES | M_SERIES | MX_SERIES | PTX_SERIES | SRX_SERIES | T_SERIES | LN_SERIES;
# BX series appears to be a solution comprised of M series, MX series, and JUNOScope software

##
# Compares two dates in the format YYYY-MM-dd
#
# @anonparam a date to compare
# @anonparam b date to compare
# @return -1 if a < b
#          0 if a == b
#          1 if a > b
##
function compare_build_dates()
{
  local_var a, b, i;
  a = _FCT_ANON_ARGS[0];
  b = _FCT_ANON_ARGS[1];

  if (isnull(a))
  {
    err_print('compare_build_dates(): missing first argument');
    return NULL;
  }
  if (isnull(b))
  {
    err_print('compare_build_dates(): missing second argument');
    return NULL;
  }

  a = split(a, sep:'-', keep:FALSE);
  b = split(b, sep:'-', keep:FALSE);

  for (i = 0; i < 3; i++)
  {
    if (int(a[i]) < int(b[i]))
      return -1;
    else if (int(a[i]) > int(b[i]))
      return 1;
  }

  return 0;
}

##
# Checks if the given model is a member of one of the series denoted by 'flags'
#
# @param model        model number to check
# @param flags        a bitmask of *_SERIES flags
# @param exit_on_fail exits if 'model' is not a member of the 'flags' series (instead of returning)
#
# @return TRUE if 'model' is a member of any of the series denoted by 'flags',
#         FALSE otherwise
##
function check_model(model, flags, exit_on_fail)
{
  if (isnull(model))
  {
    err_print('check_model(): missing argument "model"');
    return NULL;
  }
  if (isnull(flags))
  {
    err_print('check_model(): missing argument "flags"');
    return NULL;
  }

  if (flags & E_SERIES && model =~ '^E(RX)?[0-9]+')  # E-series begin with either E, or ERX. but not EX.
    return TRUE;
  else if (flags & EX_SERIES && model =~ '^EX[0-9]+')
    return TRUE;
  else if (flags & G_SERIES && model =~ '^G[0-9]+')
    return TRUE;
  else if (flags & IC_SERIES && model =~ '^IC[0-9]+')
    return TRUE;
  else if (flags & J_SERIES && model =~ '^J[0-9]+')
    return TRUE;
  else if (flags & JCS_SERIES && model =~ '^JCS[0-9]+')
    return TRUE;
  else if (flags & LN_SERIES && model =~ '^LN[0-9]+')
    return TRUE;
  else if (flags & M_SERIES && model =~ '^M[0-9]+')
    return TRUE;
  else if (flags & MX_SERIES && model =~ '^v?MX[0-9]+')
    return TRUE;
  else if (flags & PTX_SERIES && model =~ '^PTX[0-9]+')
    return TRUE;
  else if (flags & QFX_SERIES && model =~ '^QFX[0-9]+')
    return TRUE;
  else if (flags & SRX_SERIES && (model =~ '^v?SRX[0-9]+' || model =~ '^firefly-perimeter'))
    return TRUE;
  else if (flags & T_SERIES && model =~ '^T[0-9]+')
    return TRUE;

  if (exit_on_fail)
    exit(0, 'Model ' + model + ' is not affected.');
  else
    return FALSE;
}

##
# Compares two Junos version numbers.  This function assumes that the only
# valid release types are A, B, I, R, and S
#
# This function will return 0 if either 'a' or 'b' are interim releases,
# either 'a' or 'b' are not in the expected format (x.yRr.b, .b is optional),
# or the major release numbers of 'a' and 'b' are different
#
# @anonparam a first version to compare
# @anonparam b second version to compare
#
# @return -1 if 'a' is less than 'b'
#          0 if 'a' is equal to 'b'
#          1 if 'a' is greater than 'b'
##
function _junos_base_ver_compare()
{
  local_var a, b, match, a_major, b_major, a_type, b_type, a_rev, b_rev, a_build, b_build;
  a = _FCT_ANON_ARGS[0];
  b = _FCT_ANON_ARGS[1];

  # http://kb.juniper.net/InfoCenter/index?page=content&id=KB1868
  # e.g. 11.1R3.4
  # 11.1 - major version number
  # R - release type
  # 3 - revision
  # 4 - build (optional)
  match = eregmatch(string:a, pattern:'^([0-9]+\\.[0-9]+)([A-Z])([0-9]+)(\\.([0-9]+))?$');
  if (isnull(match))
  {
    err_print('junos_ver_compare(): Error parsing version : ' + a);
    return 0;
  }
  a_major = match[1];
  a_type = ord(match[2]);
  a_rev = int(match[3]);
  a_build = int(match[5]);

  match = eregmatch(string:b, pattern:'^([0-9]+\\.[0-9]+)([A-Z])([0-9]+)(\\.([0-9]+))?$');
  if (isnull(match))
  {
    err_print('junos_ver_compare(): Error parsing version : ' + b);
    return 0;
  }
  b_major = match[1];
  b_type = ord(match[2]);
  b_rev = int(match[3]);
  b_build = int(match[5]);

  # different major versions get supported differently, only like releases can be compared
  if (a_major != b_major)
    return 0;

  # Juniper says if an interim release is being used, there's no reliable way to
  # tell if it's missing security updates
  if (a_type == ord('I') || b_type == ord('I')) return 0;

  # explicitly check if alpha vs beta is being compared
  if (a_type == ord('A') && b_type == ord('B')) return -1;
  if (a_type == ord('B') && b_type == ord('A')) return 1;

  # A and B (alpha, beta) are always < R and S (release, security)
  if (a_type <= ord('B') && b_type >= ord('R')) return -1;
  if (a_type >= ord('R') && b_type <= ord('B')) return 1;

  # we should only get this far if the release types are the same,
  # or release types R and S are being compared.  For the latter
  # scenario, Juniper says the 'R' and 'S' can be ignored with
  # one exception (see below)
  if (a_rev < b_rev) return -1;
  if (a_rev > b_rev) return 1;
  if (a_build < b_build) return -1;
  if (a_build > b_build) return 1;

  # Juniper says if 'R' and 'S' versions are being compared and the major version,
  # revision, and build are identical, the 'S' version is more current
  if (a_type < b_type) return -1;
  if (a_type > b_type) return 1;

  return 0;
}

##
# Compares two Junos Space version numbers.  This function assumes that the only
# valid release types are R and P
#
# This function will return 0 if the versions are the same, and expects the
# versions to be in the format x.x[RP]x.x with [RP]x.x as optional.
#
# @param ver (first) version to compare
# @param fix (second) fixed version to compare
#
# @return -1 if 'a' is less than 'b'
#          0 if 'a' is equal to 'b'
#          1 if 'a' is greater than 'b'
##
function _junos_space_ver_compare(ver, fix)
{
  local_var match, v_major, f_major, v_minor, f_minor, v_type, f_type;
  local_var v_rev, f_rev, v_build, f_build;

  # http://kb.juniper.net/InfoCenter/index?page=content&id=KB1868
  # e.g. 11.1R3.4
  # 11.1 - major version number
  # R - release type
  # 3 - revision
  # 4 - build (optional)
  match = eregmatch(string:ver, pattern:'^([0-9]+)\\.([0-9]+)(([A-Z])([0-9]+)(\\.([0-9]+))?)?$');
  if (isnull(match))
  {
    err_print('check_junos_space(): Error parsing version: ' + ver);
    return 0;
  }
  v_major = match[1];
  v_minor = match[2];
  if (!isnull(match[4]))
    v_type = ord(match[4]);
  v_rev = int(match[5]);
  v_build = int(match[7]);

  if (v_type && (v_type != ord('R') && v_type != ord('P')))
  {
    err_print('check_junos_space(): Error invalid release type: ' + v_type);
    return 0;
  }

  match = eregmatch(string:fix, pattern:'^([0-9]+)\\.([0-9]+)(([A-Z])([0-9]+)(\\.([0-9]+))?)?$');
  if (isnull(match))
  {
    err_print('check_junos_space(): Error parsing version : ' + fix);
    return 0;
  }
  f_major = match[1];
  f_minor = match[2];
  if (!isnull(match[4]))
    f_type = ord(match[4]);
  f_rev = int(match[5]);
  f_build = int(match[7]);

  if (f_type && (f_type != ord('R') && f_type != ord('P')))
  {
    err_print('check_junos_space(): Error invalid release type: ' + f_type);
    return 0;
  }

  # With Junos Space major versions can be compared
  if (v_major < f_major) return -1;
  if (v_major > f_major) return 1;
  if (v_minor < f_minor) return -1;
  if (v_minor > f_minor) return 1;

  # Junos Space only has 'R' and 'P' types.
  # In most cases we will rather want to compare the rev and build
  if (v_rev < f_rev) return -1;
  if (v_rev > f_rev) return 1;
  if (v_build < f_build) return -1;
  if (v_build > f_build) return 1;

  # If we do have a equal Rev and Build then
  # 'P' > 'R'
  if (v_type == ord('R') && f_type == ord('P')) return -1;
  if (v_type == ord('P') && f_type == ord('R')) return 1;

  return 0;
}

##
# Compares two Junos special release version numbers
#
# This function assumes all versions will be in the format:
#
# 10.4X24
#
# Everything up to and including the X and the following numbers
# should match, and everything after should be compared.  The
# numbers are compared left to right. So the following two numbers
# would not be compared:
#
# 10.4X24
# 10.4X25.8
#
# The following two would be compared:
#
# 11.4X27.20
# 11.4X27.37
#
# This will be treated as comparing .20 to .37.  In other words, it
# makes the (perhaps incorrect) assumption that a given release train
# (for example, a 11.4X27 release) does not have multiple branches
# containing multiple fixes.
#
# @anonparam a first version to compare
# @anonparam b second version to compare
#
# @return -1 if 'a' is less than 'b'
#          0 if 'a' is equal to 'b'
#          1 if 'a' is greater than 'b'
##
function _junos_special_ver_compare()
{
  local_var a, b, a_match, b_match, a_release, b_release, a_train, b_train;
  a = _FCT_ANON_ARGS[0];
  b = _FCT_ANON_ARGS[1];

  a_match = eregmatch(string:a, pattern:"^([\d.]+X\d+)\.(\d+)");
  if (isnull(a_match))
    exit(1, 'Error parsing Junos version : ' + a);

  b_match = eregmatch(string:b, pattern:"^([\d.]+X\d+)\.(\d+)");
  if (isnull(b_match))
    exit(1, 'Error parsing Junos version : ' + b);

  a_train = a_match[1];
  a_release = a_match[2];
  b_train = b_match[1];
  b_release = b_match[2];

  # sanity checking - the parts of each version that are stripped away should match
  if (a_train != b_train)
    return NULL;

  if (int(a_release) < int(b_release))
    return -1;
  else if (int(a_release) > int(b_release))
    return 1;

  return 0;
}

##
# Compares two Junos X version numbers.
#
# Regarding 12.1X44-D10, this document says:
#   Junos 12.1 is the latest Junos release that includes security features and is
#   considered a stable release with core functionality; hence was selected as the baseline
#   for X44.
#   D10 denotes the specific release number for the X44 release train, and will be
#   incremented by 5 for maintenance releases, for example D15, D20, and so on.
#
# This function assumes all Junos X versions will be in the format:
#
# 12.2X50-D41.1
#
# In other words, everything up to and including the D should match, and
# everything after should be compared
#
# @anonparam a first version to compare
# @anonparam b second version to compare
#
# @return -1 if 'a' is less than 'b'
#          0 if 'a' is equal to 'b'
#          1 if 'a' is greater than 'b'
##
function _junos_x_ver_compare()
{
  local_var a, b, idx, a_train, b_train, a_release, b_release, i;
  a = _FCT_ANON_ARGS[0];
  b = _FCT_ANON_ARGS[1];

  # get the release number for each version.
  # for 12.2X50-D41.1, this means extracting 41.1
  idx = stridx(a, '-D');
  if (idx == -1)
    exit(1, 'Error parsing Junos version : ' + a);

  a_train = substr(a, 0, idx);
  a_release = substr(a, idx + 2);

  idx = stridx(b, '-D');
  if (idx == -1)
    exit(1, 'Error parsing Junos version : ' + b);

  b_train = substr(b, 0, idx);
  b_release = substr(b, idx + 2);

  # sanity checking - the parts of each version that are stripped away should match
  if (a_train != b_train)
    exit(1, 'Error comparing Junos versions ' + a + ' and ' + b);

  a_release = split(a_release, sep:'.', keep:FALSE);
  b_release = split(b_release, sep:'.', keep:FALSE);

  for (i = 0; i < max_index(a_release) || i < max_index(b_release); i++)
  {
    if (int(a_release[i]) < int(b_release[i]))
      return -1;
    else if (int(a_release[i]) > int(b_release[i]))
      return 1;
  }

  return 0;
}

##
# Compares two Junos version numbers including number which ends in -S.
#
# This function assumes all Junos -S versions will be in the format:
#
# 12.2R50-S41.1
#
# @anonparam a first version to compare
# @anonparam b second version to compare
#
# @return -1 if 'a' is less than 'b'
#          0 if 'a' is equal to 'b'
#          1 if 'a' is greater than 'b'
##
function _junos_ver_compare()
{
  local_var a, b, idx, a_train, b_train, a_release, b_release, i;
  a = _FCT_ANON_ARGS[0];
  b = _FCT_ANON_ARGS[1];

  # quick exit
  if (a == b) return 0;

  # get the release number for each version.
  # for 12.2S50-S41.1, this means extracting 41.1
  idx = stridx(a, '-S');
  if (idx == -1)
  {
    a_train = a;
    a_release = NULL;
  }
  else
  {
    a_train = substr(a, 0, idx-1);
    a_release = substr(a, idx + 2);
  }

  idx = stridx(b, '-S');
  if (idx == -1)
  {
    b_train = b;
    b_release = NULL;
  }
  else
  {
    b_train = substr(b, 0, idx-1);
    b_release = substr(b, idx + 2);
  }

  # if a_train != b_train then just compare them and return the result
   # or if the releases of both are null, then just compare the beginnings
  if ((a_train != b_train) || (isnull(a_release) && isnull(b_release))) return _junos_base_ver_compare(a_train, b_train);

  # check to see if either version has a null -S portion
  if (isnull(a_release)) return -1;
  if (isnull(b_release)) return 1;

  # a_train must == b_train at this point and neither version has a NULL -S portion
  # thus we compare releases
  a_release = split(a_release, sep:'.', keep:FALSE);
  b_release = split(b_release, sep:'.', keep:FALSE);

  for (i = 0; i < max_index(a_release) || i < max_index(b_release); i++)
  {
    if (int(a_release[i]) < int(b_release[i]))
      return -1;
    else if (int(a_release[i]) > int(b_release[i]))
      return 1;
  }

  return 0;
}

##
# Checks if a Junos version is out of date.
# Compares the given version to the relevant fixed version.
# If 'ver' doesn't have a corresponding fix in 'fixes', this function assumes it is not out-of-date.
#
# @param ver          version to check
# @param fixes        a hash of fixes. key = release, value = fix. e.g. 11.1 => 11.1S1
# @param exit_on_fail exits instead of returning NULL
#
# @return the appropriate fix if 'ver' is out-of-date,
#         NULL otherwise
##
function check_junos(ver, fixes, exit_on_fail)
{
  local_var match, release, fix, report, junosx, junoss, special;
  if (isnull(ver))
  {
    err_print('check_junos(): missing argument "ver".');
    return NULL;
  }
  if (isnull(fixes))
  {
    err_print('check_junos(): missing argument "fixes".');
    return NULL;
  }

  junosx = FALSE;
  special = FALSE;

  # Try to extract the release (x.y) from the version.
  #
  # X releases look different than other versions
  # (e.g., 12.2X50-D41.1 versus 10.4R13)
  #
  # there is a third kind of version that looks different. i think they're
  # called "special releases" but there may be a different, official term
  # (e.g., 11.4X27 or 12.1X44)
  if (match = eregmatch(string:ver, pattern:"^([0-9.]+X[0-9.]+)-"))
    junosx = TRUE;
  else if (match = eregmatch(string:ver, pattern:"^([0-9.]+X)[0-9.]+$"))
    special = TRUE;
  else
    match = eregmatch(string:ver, pattern:"^([0-9.]+)[A-Z]");

  if (isnull(match))
  {
    if (exit_on_fail)
      exit(1, 'check_junos(): error parsing version : ' + ver);

    err_print('check_junos(): error parsing version : ' + ver);
    return NULL;
  }
  else release = match[1];

  # If the caller says there's no fix for a given release, we're going to assume it's not vulnerable
  fix = fixes[release];
  if (isnull(fix))
  {
    if (exit_on_fail)
      exit(0, 'Junos ' + ver + ' is not affected.');
    else
      return NULL;
  }

  if (
    (junosx && _junos_x_ver_compare(ver, fix) < 0) ||
    (special && _junos_special_ver_compare(ver, fix) < 0) ||
    (!junosx && !special && !junoss && _junos_ver_compare(ver, fix) < 0)
  )
  {
    return fix;
  }
  else if (exit_on_fail)
    exit(0, 'Junos ' + ver + ' is not affected.');
  else
    return NULL;
}

##
# Checks if a Junos Space version is out of date.
# Compares the given version to the relevant fixed version.
# Will either exit or print report.
# Specifically this will flag previous versions.
#
# @param ver        The version to check
# @param fix        The fixed version
# @param severity   The severity rating for reporting
# @param min        The minimum vulnerable version
# @param xss        A boolean value to determine if the XSS kb item has to be set
# @param xsrf       A boolean value to determine if the XSRF kb item has to be set
# @param sqli       A boolean value to determine if the SQLI kb item has to be set
#
# @return NULL if there was an error.
##
function check_junos_space(ver, fix, severity, min, xss, xsrf, sqli)
{
  if (isnull(ver))
  {
    err_print('check_junos_space(): missing argument "ver"');
    return NULL;
  }
  if (isnull(fix))
  {
    err_print('check_junos_space(): missing argument "fix"');
    return NULL;
  }
  if (isnull(severity))
  {
    err_print('check_junos_space(): missing argument "severity"');
    return NULL;
  }

  if (min && _junos_space_ver_compare(ver:ver, fix:min) < 0)
    exit(0, 'Junos Space ' + ver + ' is not affected.');

  if (_junos_space_ver_compare(ver:ver, fix:fix) < 0)
  {
    if (xss)
      set_kb_item(name:'www/0/XSS', value:TRUE);
    if (xsrf)
      set_kb_item(name:'www/0/XSRF', value:TRUE);
    if (sqli)
      set_kb_item(name:'www/0/SQLInjection', value:TRUE);
    security_report_v4(port:0, extra:get_report(ver:ver, fix:fix), severity:severity);
    exit(0);
  }
  else
    exit(0, 'Junos Space ' + ver + ' is not affected.');
}

##
# Generates plugin output for on out-of-date Junos install
#
# @param model    model number of the Junos device (optional)
# @param ver      currently installed Junos version
# @param fix      version to upgrade to
#
# @return plugin output
##
function get_report(model, ver, fix)
{
  local_var report;
  report = '';

  if (!isnull(model))
    report += '\n  Model             : ' + model;

  report +=
    '\n  Installed version : ' + ver +
    '\n  Fixed version     : ' + fix + '\n';

  return report;
}
